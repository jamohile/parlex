# Parlex
Parlex, short for *parser-lexer*, consumes an input of (c-like) code and generates an abstract syntax tree (AST). The work is at a very early stage, and not all language constructs are supported, however, **broad language support is not the goal.**

## Why no target language?
This project does not target any particular input language. Instead, it seeks to create a generic parsing framework that can be easily extended to support individual languages, or even act as a "polyglot" parser.

## Project Goals

Reading on, you'll note that flexibility is a common theme in this goal. Parlex includes highly composable and extendable base parsers that can be extended to provide more complicated language specific parsing. The Parlex project's primary goal is to **bootstrap a language-specification language**. This language could then be used to automatically extend Parlex to other languages and syntaxes through auto-generated classes, making it easy to create lightweight AST parsers.

The sample 'source code' in source.txt does not confirm to any particular language, but contains some familiar structures to aid early generalized AST design.

Additionally, this project is primarily exploratory and academic in nature. It encompasses the following personal goals:
* Build a well modularized, scalable, flexible syntax parser.
  * Perform all parsing in N time.
  * Easily adapt to new language features and constructs.
* Use this parser as part of a (self developed) pipeline of source transformation tools. For example,
  * Parser
  * Optimizer
  * Compiler/Transpiler

## Project Structure
* **Lexer**: a set of tools to import, clean, and tokenize raw source files.
* **Elements**: Data classes responsible for:   
  * Storing data as "nodes" of the AST
  * Generating simple formatting of the data for console logging.
* **Parsers**: Classes responsible for parsing tokens into AST elements.
  * `/core` contains completely language agnostic parsers.
  * `/common` contains parsers for constructs that are (more or less) common between languages, such as function argument lists.

## Development
### Building
Run `g++ ./src/**/*.cpp` from the root directory.

### Running
For now, run `./a.out ./source.txt` which runs `src/main`, just some dev-testing code with a generic code-like source.

### General Principles
* There is a base element **Element** and a base parser **Parser**. All other parsers/elements derive from these classes. 
* The root level parser begins by iterating through the token array generated by the **lexer**.
  * As the parser works, it will recursively hand off parsing to "sub parsers" (described later on.)
  * When this handoff ("jump") occurs, the parent-parser passes the sub-parser the token vector and an index pointer.
  * As the sub parser works, it mutates this index pointer, allowing the parent parser to not backtrack.
* When extending the parser class, a developer defines **jumps** in the constructor. These jumps associate a particular keyword with another parser. 
  * For example, while in the root parser, the keyword "module" may trigger a **ModuleParser**.
    * Note also that a sub-parser does not define its entry condition, its parent scope does. Consider the application to a language like JavaScript, where functions can be created through multiple syntaxes. With parlex, the same function parser could understand both function types.
  * Note that these **jumps** are not global. The token "{" may trigger different parsers **depending on** the parser who finds the token.
  * A parser can define both **default jumps** and **null jumps**
    * **Default Jumps** are wildcards that map any token not matched by another jump.
    * **Null Jumps** capture a token but do not do anything with it.
  * (In progress) **K-Jumps**: When completed, these will allow Parlex to jump to another parser based on a **k-th future** token. For example, in `someFunc () {..}` it is not 'someFunc' but '()' that indicates a function is present.

### Some Parser Building Principles
#### Collection vs Composition
If you are the **root parser**, you may expect to find multiple modules, functions, etc. You don't know exactly how many entities to expect. 

As such, it's a good idea to extend the **CollectionParser**. Then, in the constructor, you can define a list of **jumps** to expect, and associate them with parsers respectively (note, recursion is okay!).

Say, however, you are a **function parser**. You know you are expecting a name, a list of arguments, and a function body. You know exactly how many elements to expect. Here, you may create a **FunctionParser** which contains:
* a name (**LiteralParser**)
* arguments (**ArgumentListParser**)
* function body (**BlockParser**)
  
(In progress) A **CompositionParser** is being developed to make it simpler to define these composite parsers.


## More documentation coming soon.